# **对象的初始化以及释放**

你知道 **alloc init new release**  这些方法都干了什么吗？

###  **对象创建**
一个简单的对象创建方式为  **[[NSObject alloc] init]**
。其中 **alloc** 和 **init** 都做了什么呢？
或者说   **[NSObject new]**

 **alloc:**  

先写结论，做了三件事：
+ **分配内存空间,生成实例对象**   
+ **初始化实例对象isa**  
+ **判断实例对象是否存在c++析构函数，如果有，则调用**


 开始看代码，找到 **NSObject.mm文件**
```

+ (id)alloc {
    return _objc_rootAlloc(self);
}

id _objc_rootAlloc(Class cls)
{
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}


static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
{
#if __OBJC2__   objc 2.0版本

// #define LLVM_LIKELY fastpath  代表大概率会走这个方法
// #define LLVM_UNLIKELY slowpath 代表大概率不走这个方法

    if (slowpath(checkNil && !cls)) return nil;
    if (fastpath(!cls->ISA()->hasCustomAWZ())) {
        return _objc_rootAllocWithZone(cls, nil);
    }
#endif
    // 这部分省略
    if (allocWithZone) {
        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);
    }
    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));
}

_objc_rootAllocWithZone 这个方法做了什么呢？(此时取的函数为的是objc-runtime-new.mm （objc-runtime-old.mm 不考虑）)
NEVER_INLINE
id
_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)
{
    // allocWithZone under __OBJC2__ ignores the zone parameter
    return _class_createInstanceFromZone(cls, 0, nil,
                                         OBJECT_CONSTRUCT_CALL_BADALLOC);
}


static ALWAYS_INLINE id
_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,
                              int construct_flags = OBJECT_CONSTRUCT_NONE,
                              bool cxxConstruct = true,
                              size_t *outAllocatedSize = nil)
{
    ASSERT(cls->isRealized());

    // Read class's info bits all at once for performance
    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();
    bool hasCxxDtor = cls->hasCxxDtor();
    bool fast = cls->canAllocNonpointer();
    size_t size;

    size = cls->instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;

    id obj;
    // 动态分配内存空间生成实例(都是c++内存分配的方法)
    if (zone) {
        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);
    } else {
        obj = (id)calloc(1, size);
    }
    if (slowpath(!obj)) {
        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {
            return _objc_callBadAllocHandler(cls);
        }
        return nil;
    }

//  下面两个初始化 Isa初始化 都最终会调用objc_object::initIsa方法 在这就不展示initIsa方法
    if (!zone && fast) {
      //initIsa(cls, true, hasCxxDtor);
        obj->initInstanceIsa(cls, hasCxxDtor);
    } else {
      // initIsa(cls, false, false);
        obj->initIsa(cls);
    }

    if (fastpath(!hasCxxCtor)) {
        return obj;
    }

    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;

    // Recursively call C++ constructors on obj, starting with base class's
    // ctor method (if any) followed by subclasses' ctors (if any), stopping    at cls's ctor (if any).

    // 翻译一下： 递归调用obj上的c++构造函数，从基类的ctor方法(如果有的话)开始，然后是子类的ctor方法(如果有的话)，直到cls的ctor为止(如果有的话)。
    // object_cxxConstructFromClass 就不详细展示了
    return object_cxxConstructFromClass(obj, cls, construct_flags);
}




```
拓展： **isa_t** 为一个联合体，所有信息公用一块内存，起到节省内存的作用。
```
union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;  // defined in isa.h
    };
#endif
};
```

在这里拓展一下 **ISA_BITFIELD** 部分,方便下面release方法的理解，引用 [iOS概念攻坚之路（三）：内存管理](https://blog.csdn.net/weixin_33816946/article/details/91380694) 中的 ***NONPOINTER_ISA*** 部分
```

ISA_BITFIELD 部分
// 以x86_64 架构 为例子

    uintptr_t nonpointer        : 1;  // 0:普通指针，1:优化过，使用位域存储更多信息
    uintptr_t has_assoc         : 1;  // 对象是否含有或曾经含有关联引用
    uintptr_t has_cxx_dtor      : 1;  // 表示是否有C++析构函数或OC的dealloc
    uintptr_t shiftcls          : 44; // 存放着 Class、Meta-Class 对象的内存地址信息
    uintptr_t magic             : 6;  // 用于在调试时分辨对象是否未完成初始化
    uintptr_t weakly_referenced : 1;  // 是否被弱引用指向
    uintptr_t deallocating      : 1;  // 对象是否正在释放
    uintptr_t has_sidetable_rc  : 1;  // 是否需要使用 sidetable 来存储引用计数
    uintptr_t extra_rc          : 8;  // 引用计数能够用 8 个二进制位存储时，直接存储在这里

```


  **init:**
从代码上看是返回了当前的对象
```
NSObject.mm 文件：

- (id)init {
    return _objc_rootInit(self);
}


id
_objc_rootInit(id obj)
{
    // In practice, it will be hard to rely on this function.
    // Many classes do not properly chain -init calls.
    return obj;
}

```

> 【注】意味着对于*NSObject*来说，多次调用*init*方法还是返回本身。



**new:**  
相当于 **[[NSObject alloc] init]]**
```
+ (id)new {
    return [callAlloc(self, false/*checkNil*/) init];
}
```

> 顺便补充一下在类方法中的self和对象方法中的self的区别

单独看源码很奇怪吧？为啥都是self，第一眼认为是同一个self
 ```
+ (id)alloc {
    return _objc_rootAlloc(self);
}
- (id)init {
    return _objc_rootInit(self);
}

```

其实在类方法中的self代表的是class，对象方法中的self代表的是当前对象。

```
测试一下

+(void)testClassFunc {
    self;
}

-(void)testInstanceFunc {
    self;
    // [self class];  等价于 +(void)testClassFunc中的self
}

通过clang编译之后的cpp文件找到对应的方法，从传参就能看出两者的区别。
我们可以看到在类方法中self的类型为Class，示例对象方法中类型为对象。

static void _C_Test_testClassFunc(Class self, SEL _cmd) {
    self;
}
static void _I_Test_testInstanceFunc(Test * self, SEL _cmd) {
    self;
}
```





###  **对象释放**

我们都知道object对象释放的时候，在mrc中是通过release方法去释放对象，那release的时候具体做了些什么呢？

找到 **NSObject-internal.h** 文件
``` -(oneway void)release {                                                     \
        __typeof__(_rc_ivar) _prev = __sync_fetch_and_sub(&_rc_ivar, 2);        \
        if (_prev > 0) {                                                        \
            return;                                                             \
        } else if (_prev < 0) {                                                 \
            __builtin_trap(); /* BUG: over-release */                           \
        }                                                                       \
        _objc_object_disposition_t fate = _logicBlock(self);                    \
        if (fate == _OBJC_RESURRECT_OBJECT) {                                   \
            return;                                                             \
        }                                                                       \
        /* mark the object as deallocating. */                                  \
        if (!__sync_bool_compare_and_swap(&_rc_ivar, -2, 1)) {                  \
            __builtin_trap(); /* BUG: dangling ref did a retain */              \
        }                                                                       \
        if (fate == _OBJC_DEALLOC_OBJECT_NOW) {                                 \
          // 此处是核心
            [self dealloc];                                                     \
        } else if (fate == _OBJC_DEALLOC_OBJECT_LATER) {                        \
            dispatch_barrier_async_f(dispatch_get_main_queue(), self,           \
                _objc_deallocOnMainThreadHelper);                               \
        } else {                                                                \
            __builtin_trap(); /* BUG: bogus fate value */                       \
        }                                                                       \
    }

```
代码中能看到核心部分是 **[self dealloc]** 部分，这里面到底处理了什么事情呢？

最后会来到 **rootDealloc** 这个方法

```
inline void
objc_object::rootDealloc()
{
    if (isTaggedPointer()) return;

    // #define LLVM_LIKELY fastpath  代表大概率会走这个方法

    if (fastpath(isa.nonpointer  &&  
                 !isa.weakly_referenced  &&  
                 !isa.has_assoc  &&  
                 !isa.has_cxx_dtor  &&  
                 !isa.has_sidetable_rc))
    {
        assert(!sidetable_present());
        free(this);
    }
    else {
        object_dispose((id)this);
    }
}

```

从上面的方法看，大概可以知道如果这个object没有 **AssociatedObjects** ，**weak对象(Sidetable对应)**, **c++的destructor(析构函数)** 会直接调用 **free** 函数。
那我们再来看 **object_dispose**函数，：

```
/***********************************************************************
* object_dispose
* fixme
* Locking: none
**********************************************************************/
id
object_dispose(id obj)
{
    if (!obj) return nil;

    objc_destructInstance(obj);    
    free(obj);

    return nil;
}

***********************************************************************
* objc_destructInstance
* Destroys an instance without freeing memory.
* Calls C++ destructors.
* Calls ARC ivar cleanup.
* Removes associative references.
* Returns `obj`. Does nothing if `obj` is nil.
**********************************************************************/
void *objc_destructInstance(id obj)
{
    if (obj) {
        // Read all of the flags at once for performance.
        bool cxx = obj->hasCxxDtor();
        bool assoc = obj->hasAssociatedObjects();

        // This order is important.
        if (cxx) object_cxxDestruct(obj);
        if (assoc) _object_remove_assocations(obj);
        obj->clearDeallocating();
    }

    return obj;
}



inline void
objc_object::clearDeallocating()
{
    if (slowpath(!isa.nonpointer)) {
        // Slow path for raw pointer isa.
        sidetable_clearDeallocating();
    }
    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {
        // Slow path for non-pointer isa with weak refs and/or side table data.
        clearDeallocating_slow();
    }

    assert(!sidetable_present());
}


// Slow path of clearDeallocating()
// for objects with nonpointer isa
// that were ever weakly referenced
// or whose retain count ever overflowed to the side table.
NEVER_INLINE void
objc_object::clearDeallocating_slow()
{
    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));

    SideTable& table = SideTables()[this];
    table.lock();
    if (isa.weakly_referenced) {
        weak_clear_no_lock(&table.weak_table, (id)this);
    }
    if (isa.has_sidetable_rc) {
        table.refcnts.erase(this);
    }
    table.unlock();
}

```

这里 **Assocation对象** 移除和 **Sidetable（和weak相关）** 就不展开讲了





> 源码参考  [objc4-781](https://opensource.apple.com/tarballs/objc4/)
